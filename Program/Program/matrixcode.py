# -*- coding: utf-8 -*-
"""MatrixCode.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g_v4sEh9kGmTOyWz4nJu9pyorscYjV0V
"""

#La regla de esto es que las matrices siempre sean n * n, donde siempre sea mil
#Moficaciones a esa matriz, todo con el fin y proposito de desarrollar la genera
#De abstracciones

print('texto')

import matplotlib.pyplot as plt
import numpy as np


variable = np.random.normal()
print(variable)

"""La idea de este comportamiento es definir los puntos en una matrix que yo pueda modificar en relacion a una conversion de traduccion de efectos sobre la matriz."""

#Como yo puedo entender el concepto que motiva el desarrollo de toda esta funcion como yo puedo organizar las relaciones de poder que permiten
#Que yo pueda seguir orientando las relaciones de una forma mas nueva.
#Somos que concepto. somos que relacion.
#Que propiedad yo quiero apreciar.
#que ruta yo quiero analizar

class Matrix:



  n = 0

  def __init__(self, numN):
    self.n = numN
    self.matrix = np.array([])
    for i in range(numN):
      list_Work = np.array([])
      for j in range(numN):
        objeto_1 = np.append(list_Work,0)
        list_Work = objeto_1
      object = np.append(self.matrix,list_Work)
      self.matrix = object
  
  def getN(self):
    return self.n
  
  def setToZero(self):
    self.matrix = np.array([])
    for i in range(self.n):
      list_Work = np.array([])
      for j in range(self.n):
        objeto_1 = np.append(list_Work,0)
        list_Work = objeto_1
      object = np.append(self.matrix,list_Work)
      self.matrix = object

  def setToOnes(self):
    self.matrix = np.array([])
    for i in range(self.n):
      list_Work = np.array([])
      for j in range(self.n):
        objeto_1 = np.append(list_Work,1)
        list_Work = objeto_1
      object = np.append(self.matrix,list_Work)
      self.matrix = object



  def matrix_translation(array_matrix_1, n_1, n_2):

#si n_2 fuera = 10 y n_1 fuera = 50, tendria que posicionar a las entidades
#de n_1 separadas de a 0.2 pixeles,
#Que parla
#
    m = n_2 / n_1

    array_matrix_2 = array_matrix_1
    return array_matrix_2


  def matrix_mod_evaluando(self, media, varianza, y):

    n_gauss = self.n
    
    ratio = 10 / n_gauss
    #Esta matrix de aqui es n * n 
    #Especificamente self.n


    #Es como el mantra de los archivos
    #Es el mismo mantra, si quieres editar el archivo, tienes que copiar toda 
    #la information borrarla, y luego actualizarla.
    


    #Traduceme los 50 * 50 
    #e^(-(x - μ)^2/(2 σ^2))/(sqrt(2 π) σ)
    array_x_1 = np.array([])
    int_count = ratio 
    for i in range(n_gauss):
      objeto_1 = np.append(array_x_1, int_count)
      int_count += ratio
      array_x_1 = objeto_1

    print(array_x_1)
    print()
    print()

    #Es la traduction 
    
    array_y_1 = np.array([])

    for i in range(n_gauss):

      float_exp = (np.exp(-1 * np.power(((array_x_1[i]) - media),2)))/(2*np.power(varianza,2))

      float_divition  = 1 / (np.sqrt(2 * np.pi) * varianza)

      float_out = y + (float_exp * float_divition)

      print(float_out)

      if(float_out <= 10 and float_out >= 0):

        objeto_1 = np.append(array_y_1, float_out)
        array_y_1 = objeto_1

      else:

        objeto_1 = np.append(array_y_1, 0)
        array_y_1 = objeto_1

#Despues de este punto tiene usted una matrix n * n con la 
#funcion gaussiana graficada.
    print()
    print()
    print(array_y_1)
    print()
    print()


    array_y_matrix = np.array([])
    for i in array_y_1:
      int_fila_matrix = i * n_gauss / 10
      objeto_1 = np.append(array_y_matrix, int(int_fila_matrix))
      array_y_matrix = objeto_1
    
    array_x_matrix = np.array([])
    for i in range(n_gauss):
      objeto_1 = np.append(array_x_matrix, i)
      array_x_matrix = objeto_1

    
    print(array_x_matrix)
    print('###########################################')
    print(array_y_matrix)

    print('###########################################')
    print('###########################################')
    print('###########################################')
    print(len(array_x_matrix))
    print(len(array_y_matrix))

    print()
    print()
    print()

#give me the coordinates of the dots, placed in the matrix
#cuz i'd give you two arrays paired with integer values so you can know the 
#the position of the dots
#que coordenada tiene la matrix n * n, cuando se mapea el punto (x_0, y_0)
    matrix = np.array([])

    # matrix = np.append(array_x_matrix,array_y_matrix)

    # print('len of the array we try to work on ')
    # print(len(matrix))

    for i in range(n_gauss):
        elemento = np.array([])
        for j in range(n_gauss):
            objeto = np.append(elemento, 0)
            elemento = objeto

        objeto_2 = np.append(matrix, elemento)
        matrix = objeto_2

    for i in range(len(array_x_matrix)):
      int_x = int(array_x_matrix.item(i))
      int_y = int(array_y_matrix.item(i))
      pos = (int_y * n_gauss) + int_x

      matrix_edit = np.delete(matrix, pos)
      matrix_edit2 = np.insert(matrix_edit, pos, 1)

      matrix = matrix_edit2

 
    
#Es hacer la convercion de que funciones, de que conceptos, de que ideas.
#Que rutas son las que yo quiero ver hechas realidad.
#Como le metemos a la creatividad
#Esa es la traduccion que estamos buscando, ese es el concepto que nosotros
#intentamos entender

    return matrix

#las modificaciones en matrices estan dadas por enteros
#La condicion para que esto corra que sea mayor o igual a 0 y menor o igual
#a 999

  def matrix_mod_constant(self, y):
    self.matrix = np.array([])
    for i in range(self.n):
      list_Work = np.array([])
      for j in range(self.n):
        if(i == y):
          objeto_1 = np.append(list_Work,2)
        else:
          objeto_1 = np.append(list_Work,0)

        list_Work = objeto_1
      object = np.append(self.matrix,list_Work)
      self.matrix = object
    return 0

#son dos arrays, unp para la x y uno para la y
  def print_matrix_matplotlib(self):
    matrix_print = self.matrix
    int_xpos = 0
    int_ypos = 0
    array_xdots = np.array([]) 
    array_ydots = np.array([])
    for i in self.matrix:
      
      if(i > 0):

        object_x = np.append(array_xdots,int_xpos)
        object_y = np.append(array_ydots,int_ypos)
        array_xdots = object_x
        array_ydots = object_y

      int_xpos += 1
      if(int_xpos == self.n):
        int_ypos += 1
        int_xpos = 0 


    array_out = np.append(array_xdots, array_ydots)
    
    return array_out


  def print_matrix_matplotlib2(self, matrix):
    matrix_print = matrix
    int_xpos = 0
    int_ypos = 0
    array_xdots = np.array([]) 
    array_ydots = np.array([])
    for i in matrix:
      
      if(i > 0):

        object_x = np.append(array_xdots,int_xpos)
        object_y = np.append(array_ydots,int_ypos)
        array_xdots = object_x
        array_ydots = object_y

      int_xpos += 1
      if(int_xpos == self.n):
        int_ypos += 1
        int_xpos = 0 


    array_out = np.append(array_xdots, array_ydots)
    
    return array_out

matrix_objeto = Matrix(3)
print(matrix_objeto.matrix)

matrix_objeto.setToOnes()
print(matrix_objeto.matrix)

matrix_objeto.setToZero()
print(matrix_objeto.matrix)

matrix_objeto = Matrix(500)

matrix_objeto.matrix_mod_constant(7)

array_dots = matrix_objeto.print_matrix_matplotlib()

print(array_dots)

matrix_gauss = matrix_objeto.matrix_mod_evaluando(4,1.2,4.5)




print()
print()

print(matrix_gauss)

print()
print()

metodo_print(matrix_objeto.print_matrix_matplotlib2(matrix_gauss))

# print()
# print()
# print()

# matrix_value = matrix_mod_evaluando(matrix_objeto.getN(),3,0.5,5)

# print(matrix_value)

# array_dots_2 = matrix_objeto.print_matrix_matplotlib2(matrix_value)

# metodo_print(array_dots_2)

matrix_gauss = Matrix(25)
matrix_prueba = matrix_mod_evaluando(25,3.0,0.5,5)
print()
print(matrix_prueba)
print()
print(matrix_gauss.print_matrix_matplotlib2(matrix_prueba))
print()

matrix_operate = matrix_gauss.print_matrix_matplotlib2(matrix_prueba)

def matrix_mod_evaluando(n, media, varianza, y):

    n_gauss = n
    
    ratio = 10 / n_gauss
    #Esta matrix de aqui es n * n 
    #Especificamente self.n


    #Es como el mantra de los archivos
    #Es el mismo mantra, si quieres editar el archivo, tienes que copiar toda 
    #la information borrarla, y luego actualizarla.
    


    #Traduceme los 50 * 50 
    #e^(-(x - μ)^2/(2 σ^2))/(sqrt(2 π) σ)
    array_x_1 = np.array([])
    int_count = ratio 
    for i in range(n_gauss):
      objeto_1 = np.append(array_x_1, int_count)
      int_count += ratio
      array_x_1 = objeto_1

    print(array_x_1)
    print()
    print()

    #Es la traduction 
    
    array_y_1 = np.array([])

    for i in range(n_gauss):

      float_exp = (np.exp(-1 * np.power(((array_x_1[i]) - media),2)))/(2*np.power(varianza,2))

      float_divition  = 1 / (np.sqrt(2 * np.pi) * varianza)

      float_out = y + (float_exp * float_divition)

      print(float_out)

      if(float_out <= 10 and float_out >= 0):

        objeto_1 = np.append(array_y_1, float_out)
        array_y_1 = objeto_1

      else:

        objeto_1 = np.append(array_y_1, 0)
        array_y_1 = objeto_1

#Despues de este punto tiene usted una matrix n * n con la 
#funcion gaussiana graficada.
    print()
    print()
    print(array_y_1)
    print()
    print()


    array_y_matrix = np.array([])
    for i in array_y_1:
      int_fila_matrix = i * n_gauss / 10
      objeto_1 = np.append(array_y_matrix, int(int_fila_matrix))
      array_y_matrix = objeto_1
    
    array_x_matrix = np.array([])
    for i in range(n_gauss):
      objeto_1 = np.append(array_x_matrix, i)
      array_x_matrix = objeto_1

    
    print(array_x_matrix)
    print('###########################################')
    print(array_y_matrix)

    print('###########################################')
    print('###########################################')
    print('###########################################')
    print(len(array_x_matrix))
    print(len(array_y_matrix))

    print()
    print()
    print()

#give me the coordinates of the dots, placed in the matrix
#cuz i'd give you two arrays paired with integer values so you can know the 
#the position of the dots
#que coordenada tiene la matrix n * n, cuando se mapea el punto (x_0, y_0)
    matrix = np.array([])

    # matrix = np.append(array_x_matrix,array_y_matrix)

    # print('len of the array we try to work on ')
    # print(len(matrix))

    for i in range(n_gauss):
        elemento = np.array([])
        for j in range(n_gauss):
            objeto = np.append(elemento, 0)
            elemento = objeto

        objeto_2 = np.append(matrix, elemento)
        matrix = objeto_2

    for i in range(len(array_x_matrix)):
      int_x = int(array_x_matrix.item(i))
      int_y = int(array_y_matrix.item(i))
      pos = (int_y * n_gauss) + int_x

      matrix_edit = np.delete(matrix, pos)
      matrix_edit2 = np.insert(matrix_edit, pos, 1)

      matrix = matrix_edit2

 
    
#Es hacer la convercion de que funciones, de que conceptos, de que ideas.
#Que rutas son las que yo quiero ver hechas realidad.
#Como le metemos a la creatividad
#Esa es la traduccion que estamos buscando, ese es el concepto que nosotros
#intentamos entender

    return matrix

int_matrix_size = 500
matrix_gauss = Matrix(int_matrix_size)
matrix_prueba = matrix_mod_evaluando(int_matrix_size,3.0,0.5,5)
array_toPlot = (matrix_gauss.print_matrix_matplotlib2(matrix_prueba))
print(matrix_prueba)

metodo_print(array_toPlot)

int_matrixSize = 100
matrix_gauss = Matrix(int_matrixSize)
matrix_prueba = matrix_mod_evaluando(int_matrixSize,3.0,0.5,5)
print()
print(matrix_prueba)
print()
print()

def metodo_print(matrix_prueba):
  array_dots_2 = matrix_prueba
  
  print('Here in branch')
  print('Here in branch')
  print('Here in branch')
  
  int_len_array_dots = len(array_dots_2)
  
  print(int_len_array_dots)
  #Filas
  y = list()
  #Columnas
  x = list()
  
  
  int_count = 0
  for i in array_dots_2:
  
    if(int_count >= ((int_len_array_dots)/2)):
      y.append(i)
    else:
      x.append(i)
    int_count += 1
  
  print(str(len(x)))
  
  print(str(len(y)))
  
  n = matrix_objeto.getN()
  int_lenx = len(x)
  
    
  sizes = list()
  colors = list()
  
  for i in range(int_lenx):
      sizes.append(200)
  
  for i in range(int_lenx):
      colors.append(50)
    
    
    
  fig, ax = plt.subplots()
  
  
  #
  #Aqui va the n                             ↓↓↓↓↓↓↓↓↓↓
  #De la matrix / of the matrix
  ax.scatter(x, y, s=sizes, c=colors, vmin=0, vmax=n)
  
  
  
  #ax.set(xlim=(0, n), xticks=np.arange(1, n),
  #ylim=(0, n), yticks=np.arange(1, n))
  
  
  plt.show()

matrix_contexto = Matrix(50)

matrix_contexto.matrix_mod_constant(25)

metodo_print(matrix_contexto.print_matrix_matplotlib())

"""**El tema con este proyecto reside en el despliege calificativo desde reales hasta enteros**

#Las matrices tienen que tener en matplotlib una definicion de 1000 * 1000, con tal de que se puedan obtener puntos dispersos en razon a una conversion y traduccion de mensajes alrededor la manipulacion de matrices

Como se pueden entender las relaciones con el saber, como puedo analizar el proyecto intelectual que me permite concebir el concepto.
Esas rutas de la mente que permiten que nuestra vision encuentre realizacion, como el desarrollo analitico hace que nuestro concepto interno sea mas pleno

Lo que podamos ir haciendo, el concepto que podamos ir desplegando

Que concepto vamos a desarrollar que ruta vamos a enfocar, la de la parla el concepto que nos permite enfocar todas nuestras opciones en pro del crecimiento del entendimiento.
"""